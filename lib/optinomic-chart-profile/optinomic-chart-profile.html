<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<!--
`optinomic-chart-profile` creates awesome Chart-Profiles. Designed for Optionmic-Apps.

## Porperties - Descrpiton
### Options

#### Example

```JS
var chart_options = {
    "min": -4,
    "max": "auto",
    "item_height": 50,
    "item_text_width": 120,
    "color_grid": "#9E9E9E",
    "show_baseline": false,
    "range_alpha": 0.1,
    "vertical_grid_every_x": 1,
    "response_title_path": "calculation.info.mz.mz_typ",
    "response_date_path": "calculation.info.filled",
    "all_profiles": true
};
```

#### Details
__min & max:__  "auto" will find the min/max automatically for you. You can also hardcode the min or max by setting it as a number.


@demo demo/index.html 
-->
<dom-module id="optinomic-chart-profile">
    <template>
        <style include="iron-flex iron-flex-alignment">
        :host {
            display: block;
            --grafic-width: 480px;
            --grafic-height: 50px;
            --grafic-margin: 0px;
            --grafic-top-space: 0px;
            --grafic-text-visibility: hidden;
            --item-height: 50px;
        }
        
        div.relative {
            position: relative;
            width: 100%;
            height: var(--grafic-height);
        }
        
        div.absolute_left {
            position: absolute;
            top: var(--grafic-top-space);
            left: 0;
            width: var(--grafic-margin);
            height: var(--grafic-height);
            text-align: right;
        }
        
        div.absolute_left_mobile {
            position: absolute;
            top: var(--grafic-top-space);
            left: 6px;
            width: var(--grafic-width);
            height: var(--grafic-height);
        }
        
        div.absolute_right {
            position: absolute;
            top: var(--grafic-top-space);
            right: 0;
            width: var(--grafic-margin);
            height: var(--grafic-height);
            visibility: var(--grafic-text-visibility);
            text-align: left;
        }
        
        div.absolute_center {
            position: absolute;
            top: 0;
            left: var(--grafic-margin);
            width: var(--grafic-size);
            height: var(--grafic-height);
        }
        
        div.vertical_grid_every_x {
            position: absolute;
            top: 0;
            height: 20px;
            margin-left: -3px;
        }
        
        div.description_item {
            padding-left: 6px;
            padding-right: 6px;
            height: var(--item-height);
            overflow: hidden;
        }
        
        .description_item_title {
            font-size: 12.5px;
            font-weight: 400;
            letter-spacing: 0.005em;
            color: #212121;
        }
        
        .caption {
            font-size: 10.6px;
            letter-spacing: 0.020em;
            line-height: 70% !important;
            color: #757575;
        }
        
        .grid-border-top {
            border-top-color: #E0E0E0;
            border-top-style: solid;
            border-top-width: 1px;
        }
        
        .fade_in {
            -webkit-animation: fadein 2s;
            /* Safari, Chrome and Opera > 12.1 */
            -moz-animation: fadein 2s;
            /* Firefox < 16 */
            -ms-animation: fadein 2s;
            /* Internet Explorer */
            -o-animation: fadein 2s;
            /* Opera < 12.1 */
            animation: fadein 2s;
        }
        
        @keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        /* Firefox < 16 */
        
        @-moz-keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        /* Safari, Chrome and Opera > 12.1 */
        
        @-webkit-keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        /* Internet Explorer */
        
        @-ms-keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        /* Opera < 12.1 */
        
        @-o-keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        </style>
        <!-- START -->
        <div class="relative" style="height:48px; !important;">
            <div class="absolute_center layout horizontal flex">
                <div class="flex">
                    <p style$="color:[[start.left_color]]">
                        [[start.left_title]]<span class="caption"><br>[[start.left_text]]</span>
                    </p>
                </div>
                <div class="flex">
                    <p style$="color:[[start.right_color]]; text-align:right">
                        [[start.right_title]]<span class="caption"><br>[[start.right_text]]</span>
                    </p>
                </div>
            </div>
        </div>
        <!-- GRAFIK -->
        <div id="svg_grafic" class="relative">
            <!-- Zahlenbeschriftung -->
            <div class="absolute_center fade_in">
                <template is="dom-repeat" items="[[verticalGrid]]" as="g">
                    <template is="dom-if" if="[[!g.last]]">
                        <div class="vertical_grid_every_x" style$="left:[[g.x]]px">
                            <p class="caption flex caption" style="color:black">[[g.value]]</p>
                        </div>
                    </template>
                    <template is="dom-if" if="[[g.last]]">
                        <div class="vertical_grid_every_x" style$="left:[[g.x]]px; text-align:right;">
                            <p class="caption flex caption" style="color:black">[[g.value]]</p>
                        </div>
                    </template>
                </template>
            </div>
            <!-- Grafik -->
            <div class="absolute_center">
                <template is="dom-if" if="[[scales_set]]">
                    <svg-container id="svg_container" view-box$="0 0 100 [[d.grafic_height]]" width="[[d.grafic_wight]]px" height$="[[d.grafic_height]]px">
                        <svg-component is="g" id="ranges" class="fade_in">
                            <template is="dom-repeat" items="[[ranges]]" as="range">
                                <svg-component class="fade_in" is="rect" x$="[[range.x]]" y$="[[range.y]]" fill$="[[range.rgb]]" width$="[[range.width]]" height$="[[range.height]]" stroke-width="none">
                                </svg-component>
                            </template>
                        </svg-component>
                        <svg-component is="g" id="horizontalGrid">
                            <template is="dom-repeat" items="[[scales]]" as="scale">
                                <svg-component is="line" x1="0" y1$="[[scale.bottomline]]" x2$="[[d.grafic_width]]" y2$="[[scale.bottomline]]" stroke$="[[d.color_grid]]" stroke-width="0.5">
                                </svg-component>
                                <template is="dom-if" if="[[scale.first]]">
                                    <svg-component is="line" x1="0" y1$="[[scale.topline]]" x2$="[[d.grafic_width]]" y2$="[[scale.topline]]" stroke$="[[d.color_grid]]" stroke-width="0.5">
                                    </svg-component>
                                </template>
                                <template is="dom-if" if="[[d.show_baseline]]">
                                    <svg-component is="line" x1="0" y1$="[[scale.baseline]]" x2$="[[d.grafic_width]]" y2$="[[scale.baseline]]" stroke$="[[d.color_grid]]" stroke-width="1">
                                    </svg-component>
                                </template>
                            </template>
                        </svg-component>
                        <svg-component is="g" id="verticalGrid">
                            <template is="dom-repeat" items="[[verticalGrid]]" as="grid">
                                <template is="dom-if" if="[[grid.zero]]">
                                    <svg-component is="line" x1$="[[grid.x]]" y1$="[[grid.y1]]" x2$="[[grid.x]]" y2$="[[grid.y2]]" stroke$="[[d.color_grid]]" stroke-width="2">
                                    </svg-component>
                                </template>
                                <template is="dom-if" if="[[!grid.zero]]">
                                    <svg-component is="line" x1$="[[grid.x]]" y1$="[[grid.y1]]" x2$="[[grid.x]]" y2$="[[grid.y2]]" stroke$="[[d.color_grid]]" stroke-width="0.1">
                                    </svg-component>
                                </template>
                            </template>
                        </svg-component>
                    </svg-container>
                </template>
            </div>
            <!-- Skalenbeschriftung: Links/Rechts -->
            <template is="dom-if" if="[[d.wide]]">
                <div class="absolute_left">
                    <template is="dom-repeat" id="left_beschriftung" items="[[scales]]" as="s">
                        <div class="description_item fade_in horizontal layout">
                            <div class="flex self-center">
                                <div class="layout horizontal flex">
                                    <p class="description_item_title flex right">[[s.left_title]]</p>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                <div class="absolute_right">
                    <template is="dom-repeat" id="right_beschriftung" items="[[scales]]" as="s">
                        <div class="description_item fade_in horizontal layout">
                            <div class="flex self-center">
                                <div class="layout horizontal flex self-center">
                                    <p class="description_item_title flex">[[s.right_title]]</p>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
            <!-- Skalenbeschriftung: Links | Mobile -->
            <template is="dom-if" if="[[!d.wide]]">
                <div class="absolute_left_mobile">
                    <template is="dom-repeat" id="right_beschriftung" items="[[scales]]" as="s">
                        <div class="description_item fade_in horizontal layout">
                            <div class="flex self-center">
                                <div class="layout horizontal flex">
                                    <p class="description_item_title flex right">[[s.left_title]]</p>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
            <!-- SVG - Profile | Alle -->
            <div class="absolute_center fade_in">
                <svg-container id="svg_container" view-box$="0 0 100 [[d.grafic_height]]" width="[[d.grafic_wight]]px" height$="[[d.grafic_height]]px">
                    <svg-component is="g" id="_score_profiles">
                        <template is="dom-repeat" items="{{_score_profiles}}" as="score">
                            <template is="dom-if" if="{{score.show}}">
                                <!-- SVG - Grafik -->
                                <svg-component is="g" id="scoreProfile" class="fade">
                                    <svg-component is="polyline" points$="[[score.points_str]]" fill="none" stroke$="[[score.color]]" stroke-width="5">
                                    </svg-component>
                                    <template is="dom-repeat" items="[[score.points]]" as="point">
                                        <svg-component is="circle" r="6" cx$="[[point.x]]" cy$="[[point.y]]" fill$="[[point.fill]]" stroke$="[[point.stroke]]" stroke-width="2" onmouseover="evt.target.setAttribute('r', '10');" onmouseout="evt.target.setAttribute('r','6');">
                                        </svg-component>
                                    </template>
                                </svg-component>
                            </template>
                        </template>
                    </svg-component>
                </svg-container>
            </div>
        </div>
    </template>
    <script>
    Polymer({

        is: 'optinomic-chart-profile',

        __init: function() {
            // Scales @ Properties
            this.scales = this.scales === undefined ? [] : this.scales;

            // Ranges @ Properties
            this.ranges = this.ranges === undefined ? [] : this.ranges;

            // Scores @ Properties
            this.scores = this.scores === undefined ? {} : this.scores;

            // Options @ Properties
            var d = this.options === undefined ? {} : this.options;
            d.color_grid = d.color_grid === undefined ? "#795548" : d.color_grid;
            d.show_baseline = d.show_baseline === undefined ? false : d.show_baseline;
            d.item_height = d.item_height === undefined ? 50 : d.item_height;
            d.item_text_width = d.item_text_width === undefined ? 120 : d.item_text_width;
            d.response_title_path = d.response_title_path === undefined ? null : d.response_title_path;
            d.response_date_path = d.response_date_path === undefined ? null : d.response_date_path;
            d.min = d.min === undefined ? "auto" : d.min;
            d.max = d.max === undefined ? "auto" : d.max;
            d.range_alpha = d.range_alpha === undefined ? 0.1 : d.range_alpha;
            d.vertical_grid_every_x = d.vertical_grid_every_x === undefined ? 1 : d.vertical_grid_every_x;


            // Resize
            d.wide = false;
            d.wide_breakpoint = 480;

            // Grafic Size
            d.grafic_top_space = 20;
            d.grafic_width = d.grafic_width === undefined ? 480 : d.grafic_width;
            d.grafic_margin = d.item_text_width;
            d.grafic_text_visibility = 'hidden';
            d.grafic_height = d.item_height * (this.scales.length) + d.grafic_top_space + 1;


            console.log('(✓) Options', d);

            // Set Data
            this.set('d', d);

        },

        __setScales: function() {
            var d = this.get('d');
            var scales = this.get('scales');
            var scores = this.get('scores.data');

            __getScorePath = function(current_score, path) {
                var data_dive = JSON.parse(JSON.stringify(current_score));
                var dots_count = (path.split(".").length - 1);

                if (dots_count === 0) {
                    return data_dive[path]
                };

                var dive = [];
                for (i = 0; i < dots_count; i++) {
                    var n = path.indexOf(".");
                    var item = path.substring(0, n);
                    path = path.substring(n + 1, path.length);
                    dive.push(item);
                    if (i === dots_count - 1) {
                        dive.push(path);
                    };
                };

                var return_value = null;

                //console.log('__getScorePath', data_dive, dive);

                for (i = 0; i < dive.length; i++) {
                    data_dive = data_dive[dive[i]];
                    if (i === dots_count) {
                        return_value = data_dive;

                        return return_value;
                    };
                };
            };

            scales.forEach(function(scale, scaleID) {
                scale.id = scaleID;
                scale.topline = scaleID * d.item_height + d.grafic_top_space;
                scale.baseline = scale.topline + (d.item_height / 2);
                scale.bottomline = scale.topline + d.item_height;

                scale.first = false;
                if (scaleID === 0) {
                    scale.first = true;
                };

                scale.last = false;
                if (scaleID === scales.length - 1) {
                    scale.last = true;
                };

                scale.scores = [];
                scores.forEach(function(score, scoreID) {
                    var score_obj = {
                        "value": null
                    };

                    // Get Values
                    if (scale.score_path) {
                        score_obj.value = this.__getScorePath(score, scale.score_path);
                    };

                    if (d.response_title_path) {
                        score_obj.title = this.__getScorePath(score, d.response_title_path);
                    } else {
                        score_obj.title = 'Unbekannt'
                    };

                    console.log(d.response_date_path);
                    if (d.response_date_path) {
                        score_obj.date = this.__getScorePath(score, d.response_date_path);
                    } else {
                        score_obj.date = null
                    };

                    scale.scores.push(score_obj);
                });
            });

            // Auto Min/Max
            var do_min = false;
            if ((d.min === 'auto') || (d.min === undefined)) {
                do_min = true;
            } else {
                item_min = parseInt(d.min);
            };

            var do_max = false;
            if ((d.max === 'auto') || (d.max === undefined)) {
                do_max = true;
            } else {
                item_max = parseInt(d.max);
            };

            if (do_max || do_min) {
                var min_max = __autoMinMax(do_min, do_max, d, this.scales);
                this.set('d.item_min', min_max.item_min);
                this.set('d.item_max', min_max.item_max);
            };


            // Set Data
            this.set('scales_set', true);
            console.log('(✓) Scales', this.scales);


            // Follow the white Rabbit
            this.__setRanges();
            this.__setVerticalGrid();
            this.__setScoreProfiles();
        },

        __setVerticalGrid: function() {

            var d = this.get('d');
            var every = d.vertical_grid_every_x;
            var every_counter = 0;

            vGrid = [];
            for (i = d.item_min; i < d.item_max + 1; i++) {
                every_counter = every_counter + 1;

                var grid_object = {
                    "count": i - d.item_min,
                    "value": i,
                    "x": __getXPos(d.item_min, d.item_max, d.grafic_width, i),
                    "y1": d.grafic_top_space,
                    "y2": d.grafic_height - 1,
                    "zero": false,
                    "first": false,
                    "last": false
                };

                if (i === 0) {
                    grid_object.zero = true;
                };

                if ((i - d.item_min) === 0) {
                    grid_object.first = true;
                };

                if ((i - d.item_max) === 0) {
                    grid_object.last = true;
                };

                if ((every_counter === every) || (i === d.item_min) || (i === d.item_max) || (i === 0)) {
                    vGrid.push(grid_object);
                    every_counter = 0;
                };
            };

            // Set Data
            this.set('verticalGrid', vGrid);
            console.log('(✓) vGrid', this.verticalGrid);
        },

        __setRanges: function() {
            var ranges = this.get('ranges');
            var d = this.get('d');

            if (ranges.length > 0) {
                ranges.forEach(function(range, rangeID) {
                    range.id = rangeID;
                    range.rgb = hexToRGB(range.color, d.range_alpha);

                    range.start = range.range_start;
                    if (range.range_start === -999) {
                        range.start = d.item_min;
                    };

                    range.stop = range.range_stop;
                    if (range.range_stop === 999) {
                        range.stop = d.item_max;
                    };

                    console.log('d.grafic_width', d.grafic_width);
                    range.start_pos = __getXPos(d.item_min, d.item_max, d.grafic_width, range.start);
                    range.stop_pos = __getXPos(d.item_min, d.item_max, d.grafic_width, range.stop);

                    range.width = range.stop_pos - range.start_pos;
                    range.x = __getXPos(d.item_min, d.item_max, d.grafic_width, range.start);
                    range.y = d.grafic_top_space;

                    range.height = d.grafic_height - d.grafic_top_space - 1;
                });

                // Set Data
                this.set('ranges', ranges);
                console.log('(✓) Ranges', this.ranges);
            };
        },

        __setScoreProfiles: function() {

            var d = this.get('d');
            var ranges = this.get('ranges');
            var scales = this.get('scales');

            var my_min = d.item_min;
            var my_max = d.item_max;
            var my_100 = d.grafic_width;


            var scores_points = [];
            scales.forEach(function(scale, scaleID) {
                scale.scores.forEach(function(score, scoreID) {

                    score.value_x = __getXPos(my_min, my_max, my_100, score.value);
                    score.value_y = scale.baseline;

                    var my_color = getColor(scoreID);

                    var score_obj = {
                        "id": scoreID,
                        "title": score.title,
                        "date": formatDateCH(score.date),
                        "points": [],
                        "points_str": "",
                        "color": my_color,
                        "color_rgb": hexToRGB(my_color, d.range_alpha),
                        "show": true
                    };

                    var points_obj = {
                        "value": score.value,
                        "x": score.value_x,
                        "y": score.value_y,
                        "stroke": my_color,
                        "fill": "white"
                    };

                    if (ranges.length > 0) {
                        ranges.forEach(function(range, rangeID) {

                            if (score.value_x >= range.start_pos && score.value_x <= range.stop_pos) {
                                points_obj.fill = range.color;
                            }

                        });
                    };

                    scores_points[scoreID] = scores_points[scoreID] === undefined ? score_obj : scores_points[scoreID];
                    scores_points[scoreID].points.push(points_obj);
                    scores_points[scoreID].points_str = scores_points[scoreID].points_str + score.value_x + ',' + score.value_y + ' ';
                });
            });

            this.set('_score_profiles', scores_points);
            console.log('(✓) score_profiles', this._score_profiles);

        },


        __resizeGrafic: function() {

            var d = this.get('d');
            d.wide = d.wide === undefined ? false : d.wide;

            var full_width = this.$.svg_grafic.offsetWidth;
            full_width = full_width;

            //this.set('d.grafic_width', 480);

            if (d.wide) {
                this.set('d.grafic_width', full_width - (2 * this.d.grafic_margin));
                this.set('d.grafic_text_visibility', 'visible');

                this.customStyle['--grafic-margin'] = this.d.grafic_margin + 'px';
            } else {
                this.set('d.grafic_width', full_width);
                this.set('d.grafic_text_visibility', 'hidden');

                this.customStyle['--grafic-margin'] = '0px';
            };

            // Apply
            this.customStyle['--grafic-top-space'] = this.d.grafic_top_space + 'px';
            this.customStyle['--item-height'] = this.d.item_height + 'px';
            this.customStyle['--grafic-height'] = this.d.grafic_height + 'px';
            this.customStyle['--grafic-size'] = this.d.grafic_width + 'px';
            this.customStyle['--grafic-text-visibility'] = this.d.grafic_text_visibility;

            this.updateStyles();


            // Follow the white Rabbit
            this.__setScales();
        },

        __onIronResize: function() {
            var width = Math.floor(this._parent.offsetWidth);
            //var height = Math.floor(this.parent.offsetHeight);

            if (width <= this.d.wide_breakpoint) {
                this.set('d.wide', false);
            } else {
                this.set('d.wide', true);
            };
            this.__resizeGrafic();
        },

        behaviors: [
            Polymer.IronResizableBehavior
        ],

        listeners: {
            'iron-resize': '__onIronResize'
        },



        properties: {
            options: {
                type: Object
            },
            start: {
                type: Object
            },
            scales: {
                type: Object
            },
            scores: {
                type: Object
            },
            ranges: {
                type: Object
            },
            _d: {
                type: Object
            },
            _score_profiles: {
                type: Object
            },
        },

        attached: function() {
            //this.__getGraficWidth();
        },

        ready: function() {
            this.__init();
        },


        get _parent() {
            if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                return this.parentNode.host;
            }
            return this.parentNode;
        },

    });

    getColor = function(id) {
        var colors = [];
        colors.push("#3F51B5");
        colors.push("#E91E63");
        colors.push("#00BCD4");
        colors.push("#8BC34A");
        colors.push("#FFC107");
        colors.push("#795548");

        colors.push("#673AB7");
        colors.push("#F44336");
        colors.push("#03A9F4");
        colors.push("#4CAF50");
        colors.push("#FFEB3B");
        colors.push("#FF5722");

        colors.push("#2196F3");
        colors.push("#9C27B0");
        colors.push("#009688");
        colors.push("#CDDC39");
        colors.push("#FF9800");
        colors.push("#607D8B");

        var selected_id = id;

        return colors[selected_id];
    };

    hexToRGB = function(hex, alpha) {
        var h = "0123456789ABCDEF";
        var r = h.indexOf(hex[1]) * 16 + h.indexOf(hex[2]);
        var g = h.indexOf(hex[3]) * 16 + h.indexOf(hex[4]);
        var b = h.indexOf(hex[5]) * 16 + h.indexOf(hex[6]);
        if (alpha) return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
        else return "rgb(" + r + ", " + g + ", " + b + ")";
    };

    __autoMinMax = function(do_min, do_max, d, all_scales) {
        // Init
        if (do_min) {
            d.item_min = 0;
        };
        if (do_max) {
            d.item_max = 0;
        };

        // Check in scales/scores
        all_scales.forEach(function(scale, scaleID) {
            scale.scores.forEach(function(score, scoreID) {
                if (do_min) {
                    if (score.value < d.item_min) {
                        d.item_min = score.value;
                    };
                };
                if (do_max) {
                    if (score.value > d.item_max) {
                        d.item_max = score.value;
                    };
                };
            });
        });


        //Round a number upward to its nearest integer:

        if (do_min) {
            if (d.item_min < 0) {
                d.item_min = Math.ceil(Math.abs(d.item_min)) + 1;
                d.item_min = d.item_min * -1;
            } else {
                d.item_min = Math.ceil(Math.abs(d.item_min)) + 1;
            };
        } else {
            d.item_min = d.min;
        };
        if (do_max) {
            if (d.item_max < 0) {
                d.item_max = Math.ceil(Math.abs(d.item_max)) + 1;
                d.item_max = d.item_max * -1;
            } else {
                d.item_max = Math.ceil(Math.abs(d.item_max)) + 1;
            };
        } else {
            d.item_max = d.max;
        };

        return d;
    };

    __getXPos = function(min, max, svg_width_100, current_value) {
        var width_value = null
        if (current_value !== undefined) {
            current_value = current_value;

            var width_100 = Math.abs(min) + Math.abs(max);
            width_value = (svg_width_100 / width_100) * (current_value + Math.abs(min));
        };
        return width_value;
    };

    formatDateCH = function(date_string) {
        if ((date_string !== undefined) && (date_string !== null)) {

            // 1952-11-19T00:00:00.000000000000Z
            var year = parseInt(date_string.substring(0, 4));
            var month = parseInt(date_string.substring(5, 7));
            var day = parseInt(date_string.substring(8, 10));
            var date_string_return = day + "." + month + "." + year

            return date_string_return;
        } else {
            return null;
        }
    };
    </script>
</dom-module>
<!-- 
http://plnkr.co/edit/pegYFTcr9koAZEg7pTMf?p=preview
-->
<dom-module id="svg-container">
    <template>
        <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" preserveAspectRatio="xMinYMin meet"></svg>
        <content select="svg-component"></content>
    </template>
    <script>
    Polymer({
        is: 'svg-container',

        attached: function() {
            for (var i = 0; i < this.attributes.length; i++) {
                this.$.svg.setAttribute(Polymer.CaseMap.dashToCamelCase(this.attributes[i].name), this.attributes[i].value);
            }
        }
    });
    </script>
</dom-module>
<dom-module id="svg-component">
    <template>
        <content select="svg-component"></content>
    </template>
    <script>
    SvgComponent = Polymer({
        is: 'svg-component',

        _node: {},

        _namespace: 'http://www.w3.org/2000/svg',

        get rootElement() {
            if (this.parentNode.nodeName === 'SVG-CONTAINER')
                return this.parentNode.$.svg;
            else
                return this.parentNode._node;
        },

        factoryImpl: function(attributes) {
            for (var key in attributes)
                this.setAttribute(key, attributes[key]);
        },

        attached: function() {
            var is = this.attributes.is.value;

            if (is !== undefined) {
                this._node = document.createElementNS(this._namespace, is);

                for (var i = 0; i < this.attributes.length; i++) {
                    if (this.attributes[i].name !== 'is')
                        this._node.setAttribute(this.attributes[i].name, this.attributes[i].value);
                }
                this.rootElement.appendChild(this._node);
            }
        }
    });
    </script>
</dom-module>
